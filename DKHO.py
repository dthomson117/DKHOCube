import copy
import numpy
import multiprocessing
import matplotlib.pyplot as plt
import cube
import random
from deap import base, algorithms
from deap import creator
from deap import tools


class DKHO:
    hall_of_fame = []
    creator.create("Fitness", base.Fitness, weights=(-1.0,))
    creator.create("Particle", list, fitness=creator.Fitness, best=None)
    creator.create("Swarm", list)

    def __init__(self, cube_to_solve, NUM_KRILL, NGEN, CXPB, MUTPB, INDPB, EVAL_DEPTH, SELECTION_SIZE, PARSIMONY_SIZE, LAMBDA):
        self.NUM_KRILL = NUM_KRILL
        self.NGEN = NGEN
        self.CXPB = CXPB
        self.MUTPB = MUTPB
        self.INDPB = INDPB
        self.EVAL_DEPTH = EVAL_DEPTH
        self.SELECTION_SIZE = SELECTION_SIZE
        self.PARSIMONY_SIZE = PARSIMONY_SIZE
        self.shuffled_cube = cube_to_solve
        self.LAMBDA = LAMBDA
        self.gbest = 1000
        pool = multiprocessing.Pool()

        toolbox = base.Toolbox()
        toolbox.register("map", pool.map)
        toolbox.register("particle", self.init_krill, creator.Particle)
        toolbox.register("swarm", tools.initRepeat, creator.Swarm, toolbox.particle)
        toolbox.register("mate", self.safe_cxOnePoint)
        toolbox.register("mutate", self.mutate, indpb=self.INDPB)
        toolbox.register("select", tools.selDoubleTournament, fitness_size=self.SELECTION_SIZE,
                         parsimony_size=self.PARSIMONY_SIZE,
                         fitness_first=True)
        toolbox.register("evaluate", self.fitness, self.EVAL_DEPTH)

        swarm = toolbox.swarm(n=self.NUM_KRILL)

        stats_fit = tools.Statistics(lambda ind: ind.fitness.values[0])
        stats_size = tools.Statistics(len)
        mstats = tools.MultiStatistics(fitness=stats_fit, size=stats_size)
        mstats.register("avg", numpy.mean, axis=0)
        mstats.register("std", numpy.std, axis=0)
        mstats.register("min", numpy.min, axis=0)
        mstats.register("max", numpy.max, axis=0)
        logbook = tools.Logbook()
        hof = tools.HallOfFame(10)

        swarm, logbook = self.eaMuPlusLambdaWithMoveSelection(swarm, toolbox, self.NUM_KRILL, self.LAMBDA, self.CXPB,
                                                              self.MUTPB, self.NGEN, mstats,
                                                              hof,
                                                              verbose=True)

        hof.update(swarm)
        self.logbook = logbook
        self.hall_of_fame = hof

    def fitness(self, depth, krill):
        """
        Assesses the fitness of a krill by getting the length of the solution generated by Kociemba's algorithm on the cube
        state that the krill is currently in.
        :param depth: Depth to run Kociemba's algorithm
        :param krill: Krill individual to assess
        :return: A tuple of the length of the solution found
        """
        temp_cube = copy.deepcopy(self.shuffled_cube)
        temp_cube.run_moves(krill)
        solution = []
        for i in range(depth):
            solve = temp_cube.solve_kociemba()
            if len(solve) < len(solution):
                solution = solve
            elif not solution:
                solution = solve

        if solution == ['']:
            return 0,
        else:
            return len(solution),

    def mutate(self, krill, indpb=0.0):
        """
        To mutate the krill, we randomly change some of its moves. indpb is the probability of a move being mutated
        :param krill: Krill individual to be possibly mutated
        :param indpb: Probability of a Krill being mutated
        :return: The mutated krill
        """

        for i, move in enumerate(krill):
            if random.random() < indpb:
                krill[i] = self.shuffled_cube.random_moves(1)[0]
        return krill,

    def move_selection(self, swarm):
        threshold = self.gbest - 1 # Set the threshold to be better than the current global best
        population = []
        for indv in swarm:
            krill = copy.deepcopy(indv) # We clone the krill to prevent issues with pointers
            fitnesses = {}

            # Current state the krill is in is krill_cube
            krill_cube = copy.deepcopy(self.shuffled_cube)
            krill_cube.run_moves(krill)

            for move in cube.Cube.move_map.keys():
                # We will clone this cube and assess each possible move on it
                temp_cube = copy.deepcopy(krill_cube)
                temp_cube.run_moves([move])
                solution = temp_cube.solve_kociemba()
                if solution == ['']: solution = [] # Set the solution to length 0 rather than length 1 if solved
                fitnesses[move] = len(solution)

            # We also allow the krill to not move
            solution = krill_cube.solve_kociemba()
            if solution == ['']: solution = []  # Set the solution to length 0 rather than length 1 if solved
            fitnesses[''] = len(solution)

            # We now have a dictionary of the fitnesses of each move

            # We will get the value of the best move(s)
            minval = min(fitnesses.values())
            best_moves = list(filter(lambda x: fitnesses[x] == minval, fitnesses))

            # If the best move(s) have a fitness below the threshold, we will choose it (or a random one if multiple)
            if minval <= threshold:
                chosen_move = random.choice(best_moves)
                #print("random best move chosen: " + chosen_move)
            # Otherwise we will randomly choose a move based on its fitness
            else:
                # We also give the option for the krill to not move
                chosen_move = self.weighted_random_choice(fitnesses)
                #print("random move chosen: " + chosen_move)

            # The krill will append the chosen move, and the fitness of that move will be assigned to the krill to prevent needless extra evaluations
            krill.append(chosen_move)
            krill.fitness.values = fitnesses[chosen_move],

            if '' in krill:
                krill.remove('') # As no move is made we remove it from the Krill so the length is appropriate

            population.append(krill)

        return population

    def safe_cxOnePoint(self, krill1, krill2):
        if len(krill1) <=1 or len(krill2) <= 1:
            return krill1, krill2
        else:
            return tools.cxOnePoint(krill1,krill2)


    def weighted_random_choice(self, choices):
        keys, values = choices.keys(), choices.values()
        weights = [1/(w + 0.00001) for w in values] # We will increase the weight ever so slightly, to avoid division by 0 errors
        return random.choices(list(choices.keys()), weights=weights, k=1)[0]

    def init_krill(self, krill):
        krill = creator.Particle()
        krill.extend(self.shuffled_cube.random_moves(random.randint(0, 2)))
        return krill

    # This is taken from the DEAP GitHub, I've replicated it here so I can modify it to have move selection for the krill
    def eaMuPlusLambdaWithMoveSelection(self, population, toolbox, mu, lambda_, cxpb, mutpb, ngen,
                                        stats=None, halloffame=None, verbose=__debug__):
        r"""This is the :math:`(\mu + \lambda)` evolutionary algorithm.
        :param population: A list of individuals.
        :param toolbox: A :class:`~deap.base.Toolbox` that contains the evolution
                        operators.
        :param mu: The number of individuals to select for the next generation.
        :param lambda_: The number of children to produce at each generation.
        :param cxpb: The probability that an offspring is produced by crossover.
        :param mutpb: The probability that an offspring is produced by mutation.
        :param ngen: The number of generation.
        :param mut_and_cross: To use both mutation and crossover, or one or the other.
        :param stats: A :class:`~deap.tools.Statistics` object that is updated
                      inplace, optional.
        :param halloffame: A :class:`~deap.tools.HallOfFame` object that will
                           contain the best individuals, optional.
        :param verbose: Whether or not to log the statistics.
        :returns: The final population
        :returns: A class:`~deap.tools.Logbook` with the statistics of the
                  evolution.
        The algorithm takes in a population and evolves it in place using the
        :func:`varOr` function. It returns the optimized population and a
        :class:`~deap.tools.Logbook` with the statistics of the evolution. The
        logbook will contain the generation number, the number of evaluations for
        each generation and the statistics if a :class:`~deap.tools.Statistics` is
        given as argument. The *cxpb* and *mutpb* arguments are passed to the
        :func:`varOr` function. The pseudocode goes as follow ::
        evaluate(population)
        for g in range(ngen):
            offspring = varOr(population, toolbox, lambda_, cxpb, mutpb)
            evaluate(offspring)
            population = select(population + offspring, mu)
        First, the individuals having an invalid fitness are evaluated. Second,
        the evolutionary loop begins by producing *lambda_* offspring from the
        population, the offspring are generated by the :func:`varOr` function. The
        offspring are then evaluated and the next generation population is
        selected from both the offspring **and** the population. Finally, when
        *ngen* generations are done, the algorithm returns a tuple with the final
        population and a :class:`~deap.tools.Logbook` of the evolution.
        This function expects :meth:`toolbox.mate`, :meth:`toolbox.mutate`,
        :meth:`toolbox.select` and :meth:`toolbox.evaluate` aliases to be
        registered in the toolbox. This algorithm uses the :func:`varOr`
        variation.
        """
        logbook = tools.Logbook()
        logbook.header = ['gen', 'nevals'] + (stats.fields if stats else [])

        count_gen = 0
        solution_found = False

        # Evaluate the individuals with an invalid fitness
        invalid_ind = [ind for ind in population if not ind.fitness.valid]
        fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
        for ind, fit in zip(invalid_ind, fitnesses):
            ind.fitness.values = fit

        if halloffame is not None:
            halloffame.update(population)

        record = stats.compile(population) if stats is not None else {}
        logbook.record(gen=0, nevals=len(invalid_ind), **record)
        if verbose:
            print(logbook.stream)

        # Begin the generational process
        #for gen in range(1, ngen + 1):
        while count_gen < ngen and not solution_found:
            count_gen += 1

            # Let each krill make a move
            population = self.move_selection(population)

            # Vary the population
            offspring = algorithms.varOr(population, toolbox, lambda_, cxpb, mutpb)

            # Evaluate the individuals with an invalid fitness
            invalid_ind = [ind for ind in offspring if not ind.fitness.values]
            fitnesses = toolbox.map(toolbox.evaluate, invalid_ind)
            for ind, fit in zip(invalid_ind, fitnesses):
                ind.fitness.values = fit
                if ind.fitness.values[0] < self.gbest:
                    self.gbest = ind.fitness.values[0]
                if ind.fitness.values[0] == 0 and len(ind) <= 24:
                    temp_cube = copy.deepcopy(self.shuffled_cube)
                    temp_cube.run_moves(ind)
                    if temp_cube.is_solved():
                        solution_found = True

            # Update the hall of fame with the generated individuals
            if halloffame is not None:
                halloffame.update(offspring + population)

            # Select the next generation population
            population[:] = toolbox.select(offspring + population, mu)

            # Update the statistics with the new population
            record = stats.compile(population) if stats is not None else {}
            logbook.record(gen=count_gen, nevals=len(invalid_ind), **record)
            if verbose:
                print(logbook.stream)

        return population, logbook

    def get_hof(self):
        return self.hall_of_fame

    def get_logbook(self):
        return self.logbook


if __name__ == '__main__':
    shuffled_cube = cube.Cube(3)
    shuffle_moves = shuffled_cube.random_moves(5)
    shuffled_cube.run_moves(shuffle_moves)
    DKHO(shuffled_cube)
